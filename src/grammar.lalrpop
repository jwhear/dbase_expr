use crate::ast::{Expression, BinaryOp, UnaryOp};
use crate::lexer::{self, Token};

//Custom lexer:
//  1.and.   should lex to "1" ".and."
//  1..and.  should lex to "1." ".and."
//  --1      should lex to "-0" "-" "1" <-- requires parse!

grammar;

extern {
    type Location = usize;
    type Error = lexer::Error;

    enum lexer::Token {
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        "->" => Token::Arrow,
        "#" => Token::Hash,
        "$" => Token::Dollar,
        LIT_TRUE => Token::LitTrue,
        LIT_FALSE => Token::LitFalse,
        LIT_NUM => Token::LitNumber(<String>),
        LIT_STRING => Token::LitString(<String>),
        OP_AND => Token::OpAnd,
        OP_OR => Token::OpOr,
        OP_NOT => Token::OpNot,
        OP_EXP => Token::OpExp,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "=" => Token::Eq,
        "<>" => Token::Neq,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Lte,
        ">=" => Token::Gte,
        IDENT => Token::Identifier(<String>),
    }
}

// Precedence climbing: each tier is a distinct precedence level. We start with
//  the lowest precedence and work our way up to "terms".
pub Expr = Or;
Or = Tier<OrOp, And>;
And = Tier<AndOp, Not>;
Not = TierUnary<NotOp, Relation>;
Relation = Tier<RelationOp, Add>;
Add = Tier<AddOp, Factor>;
Factor = Tier<FactorOp, Sign>;

//TODO need to rework this! This should be an error!
// Any number of '-' and '+' can be placed in front of an expression so we need
//  to recurse right: `--+-(foo)`
Sign: Box<Expression> = {
    <op:SignOp> <r:Sign> => Box::new(Expression::UnaryOperator(op, r)),
    Exp => <>
};
Exp = Tier<ExpOp, Term>;

pub Exprs = Comma<Expr>;

Term: Box<Expression> = {
	Bool => Box::new(Expression::BoolLiteral(<>)),
	Num => Box::new(Expression::NumberLiteral(<>)),
	StringLiteral => Box::new(Expression::StringLiteral(<>)),

	// ALIAS->FIELD
	<alias:Ident> "->" <name:Ident> => Box::new(Expression::Field{ alias: Some(alias), name }),
	// FIELD
	Ident => Box::new(Expression::Field{alias: None, name: <>}),

	Call => Box::new(Expression::FunctionCall{name: <>.0.into(), args: <>.1}),
	"(" <t:Expr> ")" => t,
};


Bool: bool = {
	LIT_TRUE => true,
	LIT_FALSE => false,
};
Num: String = LIT_NUM => <>.to_string();
Ident: String = IDENT => <>.to_string();
Call: (String, Vec<Box<Expression>>) = <name:Ident> "(" <args:Exprs> ")" => (name, args);
Field: Box<Expression> = {
	
};

StringLiteral: String = LIT_STRING => <>;

ExpOp: BinaryOp = {
	OP_EXP => BinaryOp::Exp,
};

FactorOp: BinaryOp = {
	"*" => BinaryOp::Mul,
	"/" => BinaryOp::Div,
};

AddOp: BinaryOp = {
	"+" => BinaryOp::Add,
	"-" => BinaryOp::Sub,
};

RelationOp: BinaryOp = {
	"=" => BinaryOp::Eq,
	"<>" => BinaryOp::Ne,
	"#" => BinaryOp::Ne,
	"<" => BinaryOp::Lt,
	"<=" => BinaryOp::Le,
	">" => BinaryOp::Gt,
	">=" => BinaryOp::Ge,
	"$" => BinaryOp::Contain,
};

AndOp: BinaryOp = {
	OP_AND => BinaryOp::And,
};

OrOp: BinaryOp = {
	OP_OR => BinaryOp::Or,
};

NotOp: UnaryOp = {
	OP_NOT => UnaryOp::Not,
};

SignOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
};


// Utility macros
//-------------------------------------------------------

// Matches a comma separated list of T and returns them in a Vec
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Tier<Op,NextTier>: Box<Expression> = {
	Tier<Op,NextTier> Op NextTier => Box::new(Expression::BinaryOperator(<>)),
	NextTier
};

TierUnary<Op,NextTier>: Box<Expression> = {
	Op NextTier => Box::new(Expression::UnaryOperator(<>)),
	NextTier
};
